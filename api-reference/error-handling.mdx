---
title: "Error Handling Guide"
description: "Comprehensive guide to handling API errors and edge cases"
---

# Error Handling Guide

This guide covers all possible error scenarios, status codes, and best practices for handling errors in your Jethings API integration.

## üîç Error Response Format

All API errors follow a consistent format:

```json
{
  "message": "Human-readable error description",
  "statusCode": 400
}
```

## üìä HTTP Status Codes

### 2xx Success Codes

| Code | Description | When Used |
|------|-------------|-----------|
| `200 OK` | Request successful | Most successful operations |
| `201 Created` | Resource created | User signup, admin creation |

### 4xx Client Error Codes

| Code | Description | Common Causes | Solutions |
|------|-------------|---------------|-----------|
| `400 Bad Request` | Invalid request data | Validation errors, malformed JSON | Check request format and required fields |
| `401 Unauthorized` | Authentication required | Missing/invalid token, expired token | Include valid Bearer token, refresh if expired |
| `403 Forbidden` | Insufficient permissions | Wrong role, admin-only endpoint | Verify user has required role |
| `404 Not Found` | Resource not found | Invalid endpoint, missing resource | Check endpoint URL and resource ID |
| `409 Conflict` | Resource conflict | Email/phone already exists | Use different email/phone, check existing data |
| `422 Unprocessable Entity` | Validation failed | Invalid field values | Check field validation rules |
| `429 Too Many Requests` | Rate limit exceeded | Too many requests | Implement rate limiting, retry after delay |

### 5xx Server Error Codes

| Code | Description | When to Retry | Solutions |
|------|-------------|---------------|-----------|
| `500 Internal Server Error` | Server error | Yes, with backoff | Check server status, contact support |
| `502 Bad Gateway` | Gateway error | Yes, with backoff | Retry request, check network |
| `503 Service Unavailable` | Service down | Yes, with backoff | Wait and retry, check maintenance |

## üîê Authentication Errors

### 401 Unauthorized

**Common Scenarios:**

<AccordionGroup>
  <Accordion title="Missing Token">
    **Error:**
    ```json
    {
      "message": "Authorization header is required",
      "statusCode": 401
    }
    ```
    
    **Solution:**
    ```javascript
    const response = await fetch('/api/protected-endpoint', {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      }
    });
    ```
  </Accordion>
  
  <Accordion title="Invalid Token Format">
    **Error:**
    ```json
    {
      "message": "Invalid token format",
      "statusCode": 401
    }
    ```
    
    **Solution:**
    ```javascript
    // Correct format
    'Authorization': `Bearer ${accessToken}`
    
    // Wrong formats
    'Authorization': accessToken  // Missing "Bearer "
    'Authorization': `Token ${accessToken}`  // Wrong prefix
    ```
  </Accordion>
  
  <Accordion title="Expired Token">
    **Error:**
    ```json
    {
      "message": "Token has expired",
      "statusCode": 401
    }
    ```
    
    **Solution:**
    ```javascript
    const refreshToken = await getRefreshToken();
    const newTokens = await refreshAccessToken(refreshToken);
    // Retry original request with new token
    ```
  </Accordion>
  
  <Accordion title="Invalid Token">
    **Error:**
    ```json
    {
      "message": "Invalid token",
      "statusCode": 401
    }
    ```
    
    **Solution:**
    - Check if token is corrupted
    - Verify token was obtained from correct endpoint
    - Try refreshing the token
    - If refresh fails, redirect to login
  </Accordion>
</AccordionGroup>

### 403 Forbidden

**Common Scenarios:**

<AccordionGroup>
  <Accordion title="Insufficient Role">
    **Error:**
    ```json
    {
      "message": "Insufficient permissions",
      "statusCode": 403
    }
    ```
    
    **Solution:**
    ```javascript
    // Check user role before making request
    const user = await getCurrentUser();
    if (!user.roles.includes('admin')) {
      throw new Error('Admin access required');
    }
    ```
  </Accordion>
  
  <Accordion title="Account Deactivated">
    **Error:**
    ```json
    {
      "message": "Account is deactivated",
      "statusCode": 403
    }
    ```
    
    **Solution:**
    - Contact support to reactivate account
    - Check if account was suspended
    - Verify account status with admin
  </Accordion>
</AccordionGroup>

## üìù Validation Errors

### 400 Bad Request

**Common Validation Errors:**

<AccordionGroup>
  <Accordion title="Required Fields Missing">
    **Error:**
    ```json
    {
      "message": "firstName is required",
      "statusCode": 400
    }
    ```
    
    **Solution:**
    ```javascript
    // Validate before sending
    if (!userData.firstName) {
      throw new Error('First name is required');
    }
    ```
  </Accordion>
  
  <Accordion title="Invalid Email Format">
    **Error:**
    ```json
    {
      "message": "Invalid email format",
      "statusCode": 400
    }
    ```
    
    **Solution:**
    ```javascript
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      throw new Error('Please enter a valid email address');
    }
    ```
  </Accordion>
  
  <Accordion title="Password Too Short">
    **Error:**
    ```json
    {
      "message": "Password must be at least 6 characters",
      "statusCode": 400
    }
    ```
    
    **Solution:**
    ```javascript
    if (password.length < 6) {
      throw new Error('Password must be at least 6 characters');
    }
    ```
  </Accordion>
  
  <Accordion title="Age Out of Range">
    **Error:**
    ```json
    {
      "message": "Age must be between 1 and 120",
      "statusCode": 400
    }
    ```
    
    **Solution:**
    ```javascript
    if (age < 1 || age > 120) {
      throw new Error('Age must be between 1 and 120');
    }
    ```
  </Accordion>
</AccordionGroup>

## üîÑ Conflict Errors

### 409 Conflict

**Common Conflict Scenarios:**

<AccordionGroup>
  <Accordion title="Email Already Exists">
    **Error:**
    ```json
    {
      "message": "Email already in use",
      "statusCode": 409
    }
    ```
    
    **Solution:**
    ```javascript
    try {
      await signUp(userData);
    } catch (error) {
      if (error.message.includes('Email already in use')) {
        // Offer to sign in instead
        showSignInOption();
      }
    }
    ```
  </Accordion>
  
  <Accordion title="Phone Number Already Exists">
    **Error:**
    ```json
    {
      "message": "Phone number already in use",
      "statusCode": 409
    }
    ```
    
    **Solution:**
    ```javascript
    try {
      await signUp(userData);
    } catch (error) {
      if (error.message.includes('Phone number already in use')) {
        // Ask user to use different phone number
        showPhoneConflictMessage();
      }
    }
    ```
  </Accordion>
</AccordionGroup>

## üö´ Not Found Errors

### 404 Not Found

**Common Scenarios:**

<AccordionGroup>
  <Accordion title="User Not Found">
    **Error:**
    ```json
    {
      "message": "User not found",
      "statusCode": 404
    }
    ```
    
    **Solution:**
    ```javascript
    try {
      const user = await getUserById(userId);
    } catch (error) {
      if (error.statusCode === 404) {
        // Show "User not found" message
        showNotFoundMessage();
      }
    }
    ```
  </Accordion>
  
  <Accordion title="Invalid Endpoint">
    **Error:**
    ```json
    {
      "message": "Not Found",
      "statusCode": 404
    }
    ```
    
    **Solution:**
    - Check endpoint URL spelling
    - Verify API version
    - Check if endpoint exists in documentation
  </Accordion>
</AccordionGroup>

## üîÑ Rate Limiting

### 429 Too Many Requests

**Error Response:**
```json
{
  "message": "Too many requests, please try again later",
  "statusCode": 429
}
```

**Handling Strategy:**
```javascript
const makeRequestWithRetry = async (requestFn, maxRetries = 3) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await requestFn();
    } catch (error) {
      if (error.statusCode === 429) {
        // Exponential backoff
        const delay = Math.pow(2, i) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      throw error;
    }
  }
  throw new Error('Max retries exceeded');
};
```

## üõ†Ô∏è Error Handling Patterns

### 1. Centralized Error Handler

```javascript
class ApiErrorHandler {
  static handle(error) {
    if (error.statusCode) {
      switch (error.statusCode) {
        case 400:
          return this.handleBadRequest(error);
        case 401:
          return this.handleUnauthorized(error);
        case 403:
          return this.handleForbidden(error);
        case 404:
          return this.handleNotFound(error);
        case 409:
          return this.handleConflict(error);
        case 429:
          return this.handleRateLimit(error);
        case 500:
          return this.handleServerError(error);
        default:
          return this.handleUnknownError(error);
      }
    }
    return this.handleNetworkError(error);
  }
  
  static handleBadRequest(error) {
    return {
      type: 'validation',
      message: error.message,
      action: 'Please check your input and try again'
    };
  }
  
  static handleUnauthorized(error) {
    return {
      type: 'auth',
      message: 'Please sign in to continue',
      action: 'redirect_to_login'
    };
  }
  
  static handleForbidden(error) {
    return {
      type: 'permission',
      message: 'You do not have permission to perform this action',
      action: 'contact_admin'
    };
  }
  
  static handleNotFound(error) {
    return {
      type: 'not_found',
      message: 'The requested resource was not found',
      action: 'check_url'
    };
  }
  
  static handleConflict(error) {
    return {
      type: 'conflict',
      message: error.message,
      action: 'use_different_data'
    };
  }
  
  static handleRateLimit(error) {
    return {
      type: 'rate_limit',
      message: 'Too many requests, please wait a moment',
      action: 'retry_later'
    };
  }
  
  static handleServerError(error) {
    return {
      type: 'server',
      message: 'Server error, please try again later',
      action: 'retry_later'
    };
  }
  
  static handleNetworkError(error) {
    return {
      type: 'network',
      message: 'Network error, please check your connection',
      action: 'check_connection'
    };
  }
}
```

### 2. React Hook for Error Handling

```jsx
import { useState, useCallback } from 'react';

export const useApiError = () => {
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);
  
  const handleApiCall = useCallback(async (apiCall) => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await apiCall();
      return result;
    } catch (err) {
      const handledError = ApiErrorHandler.handle(err);
      setError(handledError);
      throw handledError;
    } finally {
      setLoading(false);
    }
  }, []);
  
  const clearError = useCallback(() => {
    setError(null);
  }, []);
  
  return { error, loading, handleApiCall, clearError };
};
```

### 3. Flutter Error Handling

```dart
class ApiErrorHandler {
  static String handleError(dynamic error) {
    if (error is http.Response) {
      switch (error.statusCode) {
        case 400:
          return 'Invalid request. Please check your input.';
        case 401:
          return 'Please sign in to continue.';
        case 403:
          return 'You do not have permission for this action.';
        case 404:
          return 'The requested resource was not found.';
        case 409:
          return 'This information is already in use.';
        case 429:
          return 'Too many requests. Please wait a moment.';
        case 500:
          return 'Server error. Please try again later.';
        default:
          return 'An unexpected error occurred.';
      }
    }
    return 'Network error. Please check your connection.';
  }
  
  static void showErrorSnackBar(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
        action: SnackBarAction(
          label: 'Dismiss',
          onPressed: () {
            ScaffoldMessenger.of(context).hideCurrentSnackBar();
          },
        ),
      ),
    );
  }
}
```

## üîÑ Retry Strategies

### 1. Exponential Backoff

```javascript
const retryWithBackoff = async (fn, maxRetries = 3) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      if (error.statusCode >= 500 || error.statusCode === 429) {
        const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      
      throw error;
    }
  }
};
```

### 2. Circuit Breaker Pattern

```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.threshold = threshold;
    this.timeout = timeout;
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
  }
  
  async execute(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.threshold) {
      this.state = 'OPEN';
    }
  }
}
```

## üìä Error Monitoring

### 1. Logging Errors

```javascript
class ErrorLogger {
  static log(error, context = {}) {
    const errorData = {
      timestamp: new Date().toISOString(),
      message: error.message,
      statusCode: error.statusCode,
      stack: error.stack,
      context: context,
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    // Send to monitoring service
    this.sendToMonitoring(errorData);
    
    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.error('API Error:', errorData);
    }
  }
  
  static sendToMonitoring(errorData) {
    // Send to your monitoring service (Sentry, LogRocket, etc.)
    // Example: Sentry.captureException(error, { extra: errorData });
  }
}
```

### 2. User-Friendly Error Messages

```javascript
const getUserFriendlyMessage = (error) => {
  const errorMap = {
    'Email already in use': 'This email is already registered. Please try signing in instead.',
    'Phone number already in use': 'This phone number is already in use. Please use a different number.',
    'Invalid credentials': 'The email or password you entered is incorrect.',
    'Email not verified': 'Please verify your email address before signing in.',
    'Token has expired': 'Your session has expired. Please sign in again.',
    'Insufficient permissions': 'You do not have permission to perform this action.',
    'User not found': 'The requested user could not be found.',
    'Too many requests': 'You are making requests too quickly. Please wait a moment and try again.'
  };
  
  return errorMap[error.message] || 'An unexpected error occurred. Please try again.';
};
```

## üß™ Testing Error Scenarios

### 1. Unit Tests

```javascript
describe('Error Handling', () => {
  test('handles 401 unauthorized', async () => {
    const mockResponse = {
      status: 401,
      json: () => Promise.resolve({ message: 'Token has expired' })
    };
    
    global.fetch = jest.fn().mockResolvedValue(mockResponse);
    
    await expect(apiCall()).rejects.toThrow('Token has expired');
  });
  
  test('handles 409 conflict', async () => {
    const mockResponse = {
      status: 409,
      json: () => Promise.resolve({ message: 'Email already in use' })
    };
    
    global.fetch = jest.fn().mockResolvedValue(mockResponse);
    
    await expect(signUp({ email: 'test@example.com' }))
      .rejects.toThrow('Email already in use');
  });
});
```

### 2. Integration Tests

```javascript
describe('API Integration', () => {
  test('handles network errors gracefully', async () => {
    global.fetch = jest.fn().mockRejectedValue(new Error('Network error'));
    
    const result = await handleApiCall(() => apiCall());
    expect(result.error.type).toBe('network');
  });
  
  test('retries on 5xx errors', async () => {
    let callCount = 0;
    global.fetch = jest.fn().mockImplementation(() => {
      callCount++;
      if (callCount < 3) {
        return Promise.resolve({
          status: 500,
          json: () => Promise.resolve({ message: 'Server error' })
        });
      }
      return Promise.resolve({
        status: 200,
        json: () => Promise.resolve({ success: true })
      });
    });
    
    const result = await retryWithBackoff(() => apiCall());
    expect(callCount).toBe(3);
    expect(result.success).toBe(true);
  });
});
```

## üöÄ Best Practices

### 1. Always Handle Errors

```javascript
// ‚ùå Bad
const user = await getUserById(id);

// ‚úÖ Good
try {
  const user = await getUserById(id);
  // Handle success
} catch (error) {
  // Handle error
  console.error('Failed to get user:', error);
}
```

### 2. Provide User Feedback

```javascript
// ‚ùå Bad
try {
  await updateProfile(data);
} catch (error) {
  console.error(error);
}

// ‚úÖ Good
try {
  await updateProfile(data);
  showSuccessMessage('Profile updated successfully');
} catch (error) {
  const message = getUserFriendlyMessage(error);
  showErrorMessage(message);
}
```

### 3. Log Errors for Debugging

```javascript
// ‚ùå Bad
try {
  await apiCall();
} catch (error) {
  // Silent failure
}

// ‚úÖ Good
try {
  await apiCall();
} catch (error) {
  ErrorLogger.log(error, { userId, action: 'updateProfile' });
  showErrorMessage('Something went wrong. Please try again.');
}
```

### 4. Implement Graceful Degradation

```javascript
const loadUserData = async () => {
  try {
    const user = await getCurrentUser();
    return user;
  } catch (error) {
    // Fallback to cached data
    const cachedUser = await getCachedUser();
    if (cachedUser) {
      showWarningMessage('Using cached data. Some features may be limited.');
      return cachedUser;
    }
    
    // Last resort: redirect to login
    redirectToLogin();
  }
};
```

---

## üéØ Summary

Effective error handling is crucial for a good user experience. Remember to:

1. **Handle all error scenarios** - Don't let errors crash your app
2. **Provide clear feedback** - Users should understand what went wrong
3. **Implement retry logic** - For transient errors like network issues
4. **Log errors properly** - For debugging and monitoring
5. **Test error scenarios** - Ensure your error handling works correctly

<CardGroup cols={2}>
  <Card title="Quick Start" icon="rocket" href="/api-reference/quick-start">
    Get started with the API in minutes
  </Card>
  <Card title="Flutter Integration" icon="mobile" href="/api-reference/flutter-integration">
    Complete Flutter implementation guide
  </Card>
</CardGroup>
